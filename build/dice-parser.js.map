{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dice-parser.js","webpack:///webpack/bootstrap db9c82327a9b2eebb12c","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","flatten","xs","result","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","x","value","push","apply","err","roll","inputs","compute","prepare","rolls","reduced","reduce","rollsReducer","split","prepped","map","str","trim","replace","concat","parse","reifyRoll","_roll$split","_roll$split2","_slicedToArray","count","range","Number","toComposite","applyRoll","total","sumRolls","target","Math","floor","random","Object","defineProperty","sliceIterator","_arr","_n","_d","_e","_s","_i","TypeError","compose","_len","arguments","fns","_key","reduceRight","f","g"],"mappings":"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","file":"dice-parser.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"diceparser\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"diceparser\"] = factory();\n\telse\n\t\troot[\"diceparser\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"diceparser\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"diceparser\"] = factory();\n\telse\n\t\troot[\"diceparser\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\texports.roll = roll;\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\t// Utilities\n\t\n\t/**\n\t * Flattens nested arrays\n\t **/\n\tfunction flatten(xs) {\n\t  var result = [];\n\t\n\t  var _iteratorNormalCompletion = true;\n\t  var _didIteratorError = false;\n\t  var _iteratorError = undefined;\n\t\n\t  try {\n\t    for (var _iterator = xs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t      var x = _step.value;\n\t\n\t      if (Array.isArray(x)) {\n\t        result.push.apply(result, _toConsumableArray(flatten(x)));\n\t      } else {\n\t        result.push(x);\n\t      }\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError = true;\n\t    _iteratorError = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion && _iterator.return) {\n\t        _iterator.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError) {\n\t        throw _iteratorError;\n\t      }\n\t    }\n\t  }\n\t\n\t  return result;\n\t}\n\t\n\t/**\n\t * Composes functions, creating a processing pipeline where computed\n\t * values get chained through each of the provided functions.\n\t **/\n\tvar compose = function compose() {\n\t  for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {\n\t    fns[_key] = arguments[_key];\n\t  }\n\t\n\t  return fns.reduceRight(function (f, g) {\n\t    return function () {\n\t      return f(g.apply(undefined, arguments));\n\t    };\n\t  });\n\t};\n\t\n\t// Main\n\t\n\t/**\n\t * Computation pipeline for converting string and string[] inputs\n\t * into actual computable results.\n\t **/\n\tvar compute = compose(flatten, prepare, parse, toComposite);\n\t\n\t/**\n\t * Takes a string or array of strings and returns a CompositeDiceRoll\n\t * computed by rolling the specified dice.\n\t **/\n\tfunction roll(inputs) {\n\t  if (typeof inputs == 'string') inputs = [inputs];\n\t  return compute(inputs);\n\t}\n\t\n\texports.default = roll;\n\t\n\t/**\n\t * Takes an array of mixed strings (singular or comma-delimited)\n\t * and returns a flattened array of strings by calling `#rollsReducer`.\n\t **/\n\t\n\tfunction prepare(rolls) {\n\t  var reduced = rolls.reduce(rollsReducer, []);\n\t  return flatten(reduced);\n\t}\n\t\n\t/**\n\t * Reducing function. Takes a result array and a string then normalizes\n\t * values by trimming outside spaces, condensing consecutive spaces into\n\t * a single space, and then splitting on a variety of delimiters(\\s | ,).\n\t **/\n\tfunction rollsReducer(result, roll) {\n\t  var split = roll.split(/[|,]/);\n\t  var prepped = split.map(function (str) {\n\t    return str.trim().replace(/\\s+/g, ' ').split(' ');\n\t  });\n\t\n\t  return result.concat(flatten(prepped));\n\t}\n\t\n\t/**\n\t * Parses an array of string rolls into DiceRoll objects by\n\t * delegating the string parsing to `#reifyRoll`.\n\t **/\n\tfunction parse(rolls) {\n\t  return rolls.map(function (roll) {\n\t    return reifyRoll(roll);\n\t  });\n\t}\n\t\n\t/**\n\t * Takes an individual string roll (e.g. '2d6') and turns it into a\n\t * DiceRoll object with numeric count (2) and range (6) properties.\n\t **/\n\tfunction reifyRoll(roll) {\n\t  var _roll$split = roll.split('d');\n\t\n\t  var _roll$split2 = _slicedToArray(_roll$split, 2);\n\t\n\t  var count = _roll$split2[0];\n\t  var range = _roll$split2[1];\n\t\n\t  return { count: Number(count), range: Number(range) };\n\t}\n\t\n\t/**\n\t * Takes an array of DiceRolls and returns a CompositeDiceRoll\n\t * object which contains the DiceRolls and their computed sum.\n\t **/\n\tfunction toComposite(rolls) {\n\t  rolls = rolls.map(applyRoll);\n\t  return { rolls: rolls, total: sumRolls(rolls) };\n\t}\n\t\n\t/**\n\t * Takes an array of DiceRolls and computes the sum of the `result` attributes\n\t **/\n\tfunction sumRolls(rolls) {\n\t  return rolls.reduce(function (result, roll) {\n\t    return result + roll.result;\n\t  }, 0);\n\t}\n\t\n\t/**\n\t * Applies a given DiceRoll by generating a numer of random rolls, within\n\t * the correct range, equal to the number of dice rolled.\n\t **/\n\tfunction applyRoll(roll) {\n\t  var target = roll.count;\n\t  roll.result = 0;\n\t\n\t  while (target--) {\n\t    roll.result += 1 + Math.floor(Math.random() * roll.range);\n\t  }\n\t\n\t  return roll;\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** dice-parser.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap db9c82327a9b2eebb12c\n **/","//@flow\ntype NestedStringArray = Array<string|Array<string>>\n\ntype DiceRoll = {\n  count: number,\n  range: number,\n  result?: number\n}\n\ntype CompositeDiceRoll = {\n  rolls: DiceRoll[],\n  total: number\n}\n\n// Utilities\n\n/**\n * Flattens nested arrays\n **/\nfunction flatten<T>(xs: Array<T|Array<T>>): Array<T> {\n  let result = []\n\n  for (let x of xs) {\n    if (Array.isArray(x)) {\n      result.push(...flatten(x))\n    } else {\n      result.push(x)\n    }\n  }\n\n  return result\n}\n\n/**\n * Composes functions, creating a processing pipeline where computed\n * values get chained through each of the provided functions.\n **/\nconst compose = (...fns) => fns.reduceRight((f, g) => (...args) => f(g(...args)))\n\n// Main\n\n/**\n * Computation pipeline for converting string and string[] inputs\n * into actual computable results.\n **/\nlet compute = compose(flatten, prepare, parse, toComposite)\n\n/**\n * Takes a string or array of strings and returns a CompositeDiceRoll\n * computed by rolling the specified dice.\n **/\nexport function roll(inputs: string | NestedStringArray): CompositeDiceRoll {\n  if (typeof inputs == 'string') inputs = [inputs]\n  return compute(inputs)\n}\n\nexport default roll\n\n/**\n * Takes an array of mixed strings (singular or comma-delimited)\n * and returns a flattened array of strings by calling `#rollsReducer`.\n **/\nfunction prepare(rolls: Array<string>): Array<string> {\n  let reduced: Array<string> = rolls.reduce(rollsReducer, [])\n  return flatten(reduced)\n}\n\n/**\n * Reducing function. Takes a result array and a string then normalizes\n * values by trimming outside spaces, condensing consecutive spaces into\n * a single space, and then splitting on a variety of delimiters(\\s | ,).\n **/\nfunction rollsReducer(result: Array<string>, roll: string): Array<string> {\n  let split: Array<string> = roll.split(/[|,]/)\n  let prepped: NestedStringArray = split.map(str => str.trim().replace(/\\s+/g, ' ').split(' '))\n\n  return result.concat(flatten(prepped))\n}\n\n/**\n * Parses an array of string rolls into DiceRoll objects by\n * delegating the string parsing to `#reifyRoll`.\n **/\nfunction parse(rolls: Array<string>): DiceRoll[] {\n  return rolls.map((roll: string) => reifyRoll(roll))\n}\n\n/**\n * Takes an individual string roll (e.g. '2d6') and turns it into a\n * DiceRoll object with numeric count (2) and range (6) properties.\n **/\nfunction reifyRoll(roll: string): DiceRoll {\n  let [count, range]: Array<string> = roll.split('d')\n  return { count: Number(count), range: Number(range) }\n}\n\n/**\n * Takes an array of DiceRolls and returns a CompositeDiceRoll\n * object which contains the DiceRolls and their computed sum.\n **/\nfunction toComposite(rolls: DiceRoll[]): CompositeDiceRoll {\n  rolls = rolls.map(applyRoll)\n  return { rolls, total: sumRolls(rolls) }\n}\n\n/**\n * Takes an array of DiceRolls and computes the sum of the `result` attributes\n **/\nfunction sumRolls(rolls: Array<DiceRoll>): number {\n  return rolls.reduce((result: number, roll: DiceRoll) => result + roll.result, 0)\n}\n\n/**\n * Applies a given DiceRoll by generating a numer of random rolls, within\n * the correct range, equal to the number of dice rolled.\n **/\nfunction applyRoll(roll: DiceRoll): DiceRoll {\n  let target: number = roll.count\n  roll.result = 0\n\n  while (target--) {\n    roll.result += 1 + Math.floor(Math.random() * roll.range)\n  }\n\n  return roll\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/"],"sourceRoot":""}